<?php

/**
 * @file
 * stanford_media.install
 */

use Drupal\Component\Utility\Html;
use Drupal\Core\Entity\Entity\EntityFormDisplay;
use Drupal\Core\Template\Attribute;
use Drupal\editor\Entity\Editor;
use Drupal\embed\Entity\EmbedButton;
use Drupal\entity_browser\Entity\EntityBrowser;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\filter\Entity\FilterFormat;
use Drupal\media\Entity\MediaType;
use Drupal\views\Entity\View;
use Drupal\Core\Entity\Entity\EntityViewDisplay;

/**
 * Enable new submodule.
 */
function stanford_media_update_8001() {
  \Drupal::service('module_installer')->install(['media_duplicate_validation']);
}

/**
 * Update the media view.
 */
function stanford_media_update_8002() {
  $view = View::load('media_entity_browser');
  $list_display = &$view->getDisplay('use_list');
  $list_display['display_options']['fields']['source_id'] = [
    'id' => 'source_id',
    'field' => 'source_id',
    'group_type' => 'count_distinct',
  ];
  $list_display['display_options']['fields']['source_id'] += $list_display['display_options']['fields']['count'];
  unset($list_display['display_options']['fields']['count']);

  // Move operations column to the end.
  $operations = $list_display['display_options']['fields']['operations'];
  unset($list_display['display_options']['fields']['operations']);
  $list_display['display_options']['fields']['operations'] = $operations;

  $view->save();
}

/**
 * Change video embed field thumbnail to a lazy loading video.
 */
function stanford_media_update_8003() {
  $display = EntityViewDisplay::load('media.video.default');

  $display_options = [
    'label' => 'hidden',
    'type' => 'video_embed_field_lazyload',
    'settings' => [
      'image_style' => 'medium',
      'autoplay' => TRUE,
      'width' => 200,
      'height' => 133,
      'responsive' => FALSE,
    ],
  ];
  $display->setComponent('field_media_video_embed_field', $display_options);
  $display->save();
}

/**
 * Add `alt` and `title` attributes to the embed filter formats.
 */
function stanford_media_update_8004() {
  $entity_type_manager = \Drupal::entityTypeManager();
  $formats = $entity_type_manager->getStorage('filter_format')
    ->loadMultiple();
  /** @var \Drupal\filter\Entity\FilterFormat $filter_format */
  foreach ($formats as $filter_format) {

    $filters = $filter_format->get('filters');

    // Only need to change it if the format filters html and allows embeded
    // entities.
    if (isset($filters['filter_html']) && isset($filters['entity_embed'])) {
      preg_match("/<drupal-entity.*?>/", $filters['filter_html']['settings']['allowed_html'], $drupal_entity_tag);

      // Only need to check for alt since the UI has validation for both. If the
      // filter was modified in the UI, it will have both alt & title.
      if ($drupal_entity_tag && strpos($drupal_entity_tag[0], ' alt') === FALSE) {
        $filters['filter_html']['settings']['allowed_html'] = str_replace('<drupal-entity', '<drupal-entity alt title', $filters['filter_html']['settings']['allowed_html']);
        $filter_format->set('filters', $filters);
        $filter_format->save();
      }
    }
  }
}

/**
 * Move inline image alt text into a contrib supported attribute.
 *
 * This doesn't edit any revisions.
 */
function stanford_media_update_8005(&$sandbox) {
  if (!isset($sandbox['count'])) {
    $sandbox['entities'] = _stanford_media_update_8005_entity_list();
    $sandbox['count'] = count($sandbox['entities']);
  }

  $entity_type_manager = \Drupal::entityTypeManager();
  $entity_ids = array_splice($sandbox['entities'], 0, 25);
  foreach ($entity_ids as $item) {
    list($entity_type, $field_name, $entity_id) = explode(':', $item);
    $entity_storage = $entity_type_manager->getStorage($entity_type);
    $entity = $entity_storage->load($entity_id);

    $field_values = $entity->get($field_name)->getValue();

    foreach ($field_values as &$field_value) {
      $field_value['value'] = _stanford_media_update_8005_fix_alt($field_value['value']);
    }

    $entity->set($field_name, $field_values);
    $entity->save();
  }
  $sandbox['#finished'] = empty($sandbox['entities']) ? 1 : ($sandbox['count'] - count($sandbox['entities'])) / $sandbox['count'];
}

/**
 * Get the list of entities needing updates.
 *
 * @return array
 *   List of values with entity type, field and id.
 */
function _stanford_media_update_8005_entity_list() {
  $list = [];
  foreach (_stanford_media_update_8005_get_filter_fields() as $field) {
    list($entity_type, $field_name) = explode(':', $field);

    try {
      $entity_ids = \Drupal::entityQuery($entity_type)
        ->condition($field_name, '%alt_text&quot%', 'LIKE')
        ->execute();
    }
    catch (Exception $e) {
      continue;
    }

    foreach ($entity_ids as $entity_id) {
      $list[] = "$entity_type:$field_name:$entity_id";
    }
  }
  asort($list);
  return array_unique($list);
}

/**
 * Get a list of all fields that are filtered.
 *
 * @return array
 *   Array of values with entity type and field name.
 */
function _stanford_media_update_8005_get_filter_fields() {
  $field_manager = \Drupal::service('entity_field.manager');
  $filtered_text_fields = ['text', 'text_long', 'text_with_summary'];

  $filtered_fields = [];
  foreach ($field_manager->getFieldMap() as $entity_type => $fields) {
    foreach ($fields as $field_name => $field_info) {
      if (!in_array($field_info['type'], $filtered_text_fields)) {
        continue;
      }

      $filtered_fields[] = "$entity_type:$field_name";
    }
  }
  asort($filtered_fields);
  return array_unique($filtered_fields);
}

/**
 * Move the alt_text value in the json data into an `alt` attribute.
 *
 * @param string $html
 *   Original Html with the embed entity tag.
 *
 * @return string
 *   Fixed html.
 */
function _stanford_media_update_8005_fix_alt($html) {
  preg_match_all("/<drupal-entity.*?\/drupal-entity>/s", $html, $tokens);
  foreach ($tokens[0] as $token) {
    // Existing tokens already use the contrib attribute or dont use an alt at
    // all.
    if (strpos($token, ' alt="') !== FALSE || strpos($token, 'alt_text&quot') === FALSE) {
      continue;
    }

    $new_token = $token;

    preg_match("/data-entity-embed-display-settings=\".*?\"/", $new_token, $settings);
    $display_settings = str_replace('data-entity-embed-display-settings="', '', $settings[0]);
    $display_settings = substr($display_settings, 0, -1);
    $display_settings = json_decode(htmlspecialchars_decode($display_settings), TRUE);

    $alt_text = $display_settings['alt_text'];
    unset($display_settings['alt_text']);
    $new_token = str_replace($settings[0], 'data-entity-embed-display-settings="' . htmlspecialchars(json_encode($display_settings)) . '"', $new_token);

    $new_token = str_replace('<drupal-entity ', "<drupal-entity alt=\"$alt_text\" ", $new_token);

    $html = str_replace($token, $new_token, $html);
  }
  return $html;
}

/**
 * Merge two setting configs into one.
 */
function stanford_media_update_8006() {
  $config_factory = \Drupal::configFactory();

  $old_image_styles = $config_factory->getEditable('stanford_media.embeddable_image_styles');
  $old_captions = $config_factory->getEditable('stanford_media.allowed_caption_formats');

  $new_settings = $config_factory->getEditable('stanford_media.settings');
  $new_settings->set('embeddable_image_styles', $old_image_styles->get('allowed_styles'));
  $new_settings->set('allowed_caption_formats', $old_captions->get('allowed_formats'));
  $new_settings->save();

  $old_image_styles->delete();
  $old_captions->delete();
}

/**
 * Convert media browser field widgets to media library widgets.
 */
function stanford_media_update_8200() {
  \Drupal::service('module_installer')->install(['media_library']);
  $media_library_widget = ['type' => 'media_library_widget'];

  /** @var EntityFormDisplay $form_display */
  foreach (EntityFormDisplay::loadMultiple() as $form_display) {
    $form_modified = FALSE;
    foreach ($form_display->getComponents() as $component_name => $settings) {
      if (isset($settings['type']) && $settings['type'] == 'entity_browser_entity_reference') {
        $media_library_widget['weight'] = $settings['weight'];
        $form_display->setComponent($component_name, $media_library_widget);
        $form_modified = TRUE;
      }
    }

    if ($form_modified) {
      $form_display->save();
    }
  }

}

/**
 * Update text formats by switching the media buttons.
 */
function stanford_media_update_8201() {

  /** @var \Drupal\editor\EditorInterface $editor */
  foreach (Editor::loadMultiple() as $editor) {

    $settings = $editor->getSettings();
    foreach ($settings['toolbar']['rows'] as &$row_items) {
      foreach ($row_items as &$row_group) {
        if ($media_browser_position = array_search('media_browser', $row_group['items'])) {
          $row_group['items'][$media_browser_position] = 'DrupalMediaLibrary';
          $editor->setSettings($settings);
          $editor->save();
        }
      }
    }

  }

  /** @var \Drupal\filter\FilterFormatInterface $filter */
  foreach (FilterFormat::loadMultiple() as $filter) {
    $filters = $filter->get('filters');
    if (isset($filters['entity_embed'])) {
      $filters['media_embed'] = [
        'id' => 'media_embed',
        'provider',
        'media',
        'status' => TRUE,
        'weight' => $filters['entity_embed']['weight'],
        'settings' => [
          'default_view_mode' => 'full',
          'allowed_view_modes' => [],
        ],
      ];
      // Make sure if the filter strips html tags, we need to keep the
      // drupal-media tag and its attributes.
      if (isset($filters['filter_html'])) {
        $filters['filter_html']['settings']['allowed_html'] .= ' <drupal-media data-entity-type data-entity-uuid data-align data-caption data-* alt>';
      }
      $filter->set('filters', $filters);
      $filter->save();
    }
  }
}

/**
 * Convert drupal-entity tags in wysiwyg's to drupal-media tags.
 */
function stanford_media_update_8202(&$sandbox) {
  if (!isset($sandbox['count'])) {
    $sandbox['entities'] = _stanford_media_update_8202_entity_list();
    $sandbox['count'] = count($sandbox['entities']);
  }

  $entity_type_manager = \Drupal::entityTypeManager();
  $entity_ids = array_splice($sandbox['entities'], 0, 25);
  foreach ($entity_ids as $item) {
    list($entity_type, $field_name, $entity_id) = explode(':', $item);

    $entity = $entity_type_manager->getStorage($entity_type)->load($entity_id);
    $field_values = $entity->get($field_name)->getValue();

    foreach ($field_values as &$field_value) {
      $field_value['value'] = _stanford_media_update_8202_change_tag($field_value['value']);
    }

    $entity->set($field_name, $field_values);
    $entity->save();
  }

  $sandbox['#finished'] = empty($sandbox['entities']) ? 1 : ($sandbox['count'] - count($sandbox['entities'])) / $sandbox['count'];
}

/**
 * Parse the drupal-entity tag, and change it into drupal-media tag.
 *
 * TODO: video options.
 *
 * @param string $html
 *   Original html markup
 *
 * @return string
 *   New html markup with corrected tokens.
 */
function _stanford_media_update_8202_change_tag($html) {
  preg_match_all("/<drupal-entity.*?\/drupal-entity>/s", $html, $tokens);
  foreach ($tokens[0] as $token) {
    $token_dom = Html::load($token);
    $token_element = $token_dom->getElementsByTagName('drupal-entity')->item(0);

    $attributes = [
      'data-entity-uuid',
      'alt',
      'data-align',
    ];
    $new_token_attributes = new Attribute();
    $new_token_attributes->setAttribute('data-entity-type', 'media');

    foreach ($attributes as $attribute) {
      if ($value = $token_element->getAttribute($attribute)) {
        $new_token_attributes->setAttribute($attribute, $value);
      }
    }

    $display_settings = json_decode($token_element->getAttribute('data-entity-embed-display-settings'), TRUE);
    if (isset($display_settings['image_style'])) {
      $new_token_attributes->setAttribute('data-image-style', $display_settings['image_style']);
    }
    if (isset($display_settings['description'])) {
      $new_token_attributes->setAttribute('data-display-description', $display_settings['description']);
    }

    if ($caption_data = json_decode(htmlspecialchars_decode($token_element->getAttribute('data-caption')), TRUE)) {
      $caption_text = strip_tags(check_markup($caption_data['value'], $caption_data['format']), '<a>');
      $new_token_attributes->setAttribute('data-caption', $caption_text ?: $caption_data['value']);
    }

    $new_token = "<drupal-media$new_token_attributes></drupal-media>";

    if (!empty($display_settings['linkit']['href'])) {
      $link_attributes = new Attribute($display_settings['linkit']);
      $new_token = "<a$link_attributes>$new_token</a>";
    }
    $html = str_replace($token, $new_token, $html);
  }

  return $html;
}

/**
 * Get the list of entities with drupal-entity tokens.
 *
 * @return array
 *   List of entities needing fixed.
 */
function _stanford_media_update_8202_entity_list() {
  $list = [];
  foreach (_stanford_media_update_8005_get_filter_fields() as $field) {
    list($entity_type, $field_name) = explode(':', $field);

    try {
      $entity_ids = \Drupal::entityQuery($entity_type)
        ->condition($field_name, '<drupal-entity', 'CONTAINS')
        ->execute();
    }
    catch (Exception $e) {
      continue;
    }

    foreach ($entity_ids as $entity_id) {
      $list[] = "$entity_type:$field_name:$entity_id";
    }
  }
  asort($list);
  return array_unique($list);
}

/**
 * Migrate video data to core supported fields.
 */
function stanford_media_update_8203() {
  if (!FieldStorageConfig::load('media.field_media_oembed_video')) {
    FieldStorageConfig::create([
      'field_name' => 'field_media_oembed_video',
      'entity_type' => 'media',
      'type' => 'string',
    ])->save();
  }
  if (!FieldConfig::load('media.video.field_media_oembed_video')) {
    FieldConfig::create([
      'field_name' => 'field_media_oembed_video',
      'label' => 'Video URL',
      'entity_type' => 'media',
      'bundle' => 'video',
      'required' => TRUE,
    ])->save();
  }
  /** @var \Drupal\Core\Entity\Display\EntityFormDisplayInterface $display */
  foreach (EntityFormDisplay::loadMultiple() as $display) {
    if ($display->getTargetEntityTypeId() == 'media' && $display->getTargetBundle() == 'video') {
      $display->removeComponent('field_media_video_embed_field');
      $display->setComponent('field_media_oembed_video');
    }
  }

  drupal_flush_all_caches();

  $video_medias = \Drupal::entityTypeManager()
    ->getStorage('media')
    ->loadByProperties(['bundle' => 'video']);
  /** @var \Drupal\media\MediaInterface $media */
  foreach ($video_medias as $media) {
    if (empty($media->get('field_media_oembed_video')->getString())) {
      $video_url = $media->get('field_media_video_embed_field')->getString();
      $media->set('field_media_oembed_video', $video_url);
      $media->save();
    }
  }

  $source_config = [
    'source_field' => 'field_media_oembed_video',
    'providers' => ['YouTube', 'Vimeo'],
    'thumbnails_directory' => 'public://oembed_thumbnails',
  ];
  /** @var \Drupal\media\MediaTypeInterface $media_type */
  $media_type = MediaType::load('video');
  $media_type->set('source_configuration', $source_config);
  $media_type->set('source', 'oembed:video');
  $media_type->save();
}

/**
 * Delete unused configs now.
 */
function stanford_media_update_8204() {
  $browsers = EntityBrowser::loadMultiple([
    'file_browser',
    'image_browser',
    'media_browser',
    'video_browser',
  ]);
  foreach ($browsers as $browser) {
    $browser->delete();
  }

  EmbedButton::load('media_browser')->delete();
  View::load('media_entity_browser')->delete();
  \Drupal::messenger()
    ->addMessage(t('Review these modules to see if they still require being enabled: entity_browser, embed, & entity_embed'));
}
